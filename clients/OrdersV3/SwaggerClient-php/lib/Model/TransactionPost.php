<?php
/**
 * TransactionPost
 *
 * PHP version 5
 *
 * @category Class
 * @package  BigCommerce\OrdersV3
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Orders V3
 *
 * Surfaces endpoints related to payment processing. The `/orders/{id}/transactions` endpoint returns transaction details for the specified order. To programmatically create, update, and delete orders themselves, see [Orders v2](https://developer.bigcommerce.com/api-reference/store-management/orders). To process payments, see [Payment Processing](https://developer.bigcommerce.com/api-reference/payments/payments-process-payments).  - [Authentication](#authentication) - [Available Endpoints](#available-endpoints) - [Order Transactions](#order-transactions) - [Order refunds](#order-refunds) - [Resources](#resources)  ## Authentication  Authenticate requests by including an [OAuth](https://developer.bigcommerce.com/api-docs/getting-started/authentication) `access_token` and `client_id` in the request headers.  ```http GET https://api.bigcommerce.com/stores/{{STORE_HASH}}/v3/{{ENDPOINT}} Content-Type: application/json X-Auth-Client: {{CLIENT_ID}} X-Auth-Token: {{ACCESS_TOKEN}} ```  ### OAuth Scopes  | UI Name| Permission |Parameter|                                      |----------------------------------------------|------------|----------| | Order Transactions|modify|`store_v2_transactions`| | Order Transactions|read-only  |`store_v2_transactions_read_only`| | Orders| modify|`store_v2_orders`| | Orders| read-only|`store_v2_orders_read_only`|  ## Order Transactions The `/orders/{id}/transactions` endpoint returns details about the payment instruments used to pay for an order. Depending on the payment method used, different details will be available. Not all credit card payment gateways return full card or fraud details. Transactions endpoints are primarily used to get detailed gateway response information for credit card transactions; however they will also return any available information about digital wallet and offline payments.   **Note**: transactions are not created for the following payment methods: * Test Payment Gateway * PayPal Express * Amazon Pay  ## Order Refunds The Order API refund endpoints allow developers to process refunds against orders with settled payments. Refund endpoints are useful when building order management or payment integrations. They make embedding refund functionality directly into the application possible without requiring merchants to return to their BigCommerce Control Panel.  ## Resources * [Orders Overview](https://developer.bigcommerce.com/api-docs/orders/orders-overview) * [Orders V2](https://developer.bigcommerce.com/api-reference/store-management/orders)
 *
 * OpenAPI spec version: 1.0.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 3.0.21
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace BigCommerce\OrdersV3\Model;

use \ArrayAccess;
use \BigCommerce\OrdersV3\ObjectSerializer;

/**
 * TransactionPost Class Doc Comment
 *
 * @category Class
 * @package  BigCommerce\OrdersV3
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class TransactionPost implements ModelInterface, ArrayAccess
{
    const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $swaggerModelName = 'Transaction_Post';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerTypes = [
        'event' => 'string',
'method' => 'string',
'amount' => 'float',
'currency' => 'string',
'gateway' => 'string',
'gateway_transaction_id' => 'string',
'date_created' => '\DateTime',
'test' => 'bool',
'status' => 'string',
'fraud_review' => 'bool',
'reference_transaction_id' => 'int',
'offline' => '\BigCommerce\OrdersV3\Model\Offline1',
'custom' => '\BigCommerce\OrdersV3\Model\Custom1'    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerFormats = [
        'event' => null,
'method' => null,
'amount' => 'float',
'currency' => 'ISO-4217',
'gateway' => null,
'gateway_transaction_id' => null,
'date_created' => 'date-time',
'test' => null,
'status' => null,
'fraud_review' => null,
'reference_transaction_id' => null,
'offline' => null,
'custom' => null    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerTypes()
    {
        return self::$swaggerTypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerFormats()
    {
        return self::$swaggerFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'event' => 'event',
'method' => 'method',
'amount' => 'amount',
'currency' => 'currency',
'gateway' => 'gateway',
'gateway_transaction_id' => 'gateway_transaction_id',
'date_created' => 'date_created',
'test' => 'test',
'status' => 'status',
'fraud_review' => 'fraud_review',
'reference_transaction_id' => 'reference_transaction_id',
'offline' => 'offline',
'custom' => 'custom'    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'event' => 'setEvent',
'method' => 'setMethod',
'amount' => 'setAmount',
'currency' => 'setCurrency',
'gateway' => 'setGateway',
'gateway_transaction_id' => 'setGatewayTransactionId',
'date_created' => 'setDateCreated',
'test' => 'setTest',
'status' => 'setStatus',
'fraud_review' => 'setFraudReview',
'reference_transaction_id' => 'setReferenceTransactionId',
'offline' => 'setOffline',
'custom' => 'setCustom'    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'event' => 'getEvent',
'method' => 'getMethod',
'amount' => 'getAmount',
'currency' => 'getCurrency',
'gateway' => 'getGateway',
'gateway_transaction_id' => 'getGatewayTransactionId',
'date_created' => 'getDateCreated',
'test' => 'getTest',
'status' => 'getStatus',
'fraud_review' => 'getFraudReview',
'reference_transaction_id' => 'getReferenceTransactionId',
'offline' => 'getOffline',
'custom' => 'getCustom'    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$swaggerModelName;
    }

    const EVENT_PURCHASE = 'purchase';
const EVENT_AUTHORIZATION = 'authorization';
const EVENT_CAPTURE = 'capture';
const EVENT_REFUND = 'refund';
const EVENT_VOID = 'void';
const EVENT_PENDING = 'pending';
const EVENT_SETTLED = 'settled';
const METHOD_CREDIT_CARD = 'credit_card';
const METHOD_ELECTRONIC_WALLET = 'electronic_wallet';
const METHOD_GIFT_CERTIFICATE = 'gift_certificate';
const METHOD_STORE_CREDIT = 'store_credit';
const METHOD_APPLE_PAY_CARD = 'apple_pay_card';
const METHOD_APPLE_PAY_TOKEN = 'apple_pay_token';
const METHOD_TOKEN = 'token';
const METHOD_CUSTOM = 'custom';
const METHOD_OFFSITE = 'offsite';
const METHOD_OFFLINE = 'offline';
const METHOD_NONCE = 'nonce';
const GATEWAY__2CHECKOUT = '2checkout';
const GATEWAY_ADYEN = 'adyen';
const GATEWAY_AMAZON = 'amazon';
const GATEWAY_AUTHORIZENET = 'authorizenet';
const GATEWAY_BANKDEPOSIT = 'bankdeposit';
const GATEWAY_BRAINTREE = 'braintree';
const GATEWAY_CHEQUE = 'cheque';
const GATEWAY_COD = 'cod';
const GATEWAY_CUSTOM = 'custom';
const GATEWAY_FIRSTDATAGGE4 = 'firstdatagge4';
const GATEWAY_GIFTCERTIFICATE = 'giftcertificate';
const GATEWAY_HPS = 'hps';
const GATEWAY_INSTORE = 'instore';
const GATEWAY_KLARNA = 'klarna';
const GATEWAY_MIGS = 'migs';
const GATEWAY_MONEYORDER = 'moneyorder';
const GATEWAY_NMI = 'nmi';
const GATEWAY_PAYPALEXPRESS = 'paypalexpress';
const GATEWAY_PAYPALPAYMENTSPROUS = 'paypalpaymentsprous';
const GATEWAY_PAYPALPAYMENTSPROUK = 'paypalpaymentsprouk';
const GATEWAY_PLUGNPAY = 'plugnpay';
const GATEWAY_QBMSV2 = 'qbmsv2';
const GATEWAY_SECURENET = 'securenet';
const GATEWAY_SQUARE = 'square';
const GATEWAY_STORECREDIT = 'storecredit';
const GATEWAY_STRIPE = 'stripe';
const GATEWAY_TESTGATEWAY = 'testgateway';
const GATEWAY_USAEPAY = 'usaepay';
const STATUS_OK = 'ok';
const STATUS_ERROR = 'error';

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getEventAllowableValues()
    {
        return [
            self::EVENT_PURCHASE,
self::EVENT_AUTHORIZATION,
self::EVENT_CAPTURE,
self::EVENT_REFUND,
self::EVENT_VOID,
self::EVENT_PENDING,
self::EVENT_SETTLED,        ];
    }
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getMethodAllowableValues()
    {
        return [
            self::METHOD_CREDIT_CARD,
self::METHOD_ELECTRONIC_WALLET,
self::METHOD_GIFT_CERTIFICATE,
self::METHOD_STORE_CREDIT,
self::METHOD_APPLE_PAY_CARD,
self::METHOD_APPLE_PAY_TOKEN,
self::METHOD_TOKEN,
self::METHOD_CUSTOM,
self::METHOD_OFFSITE,
self::METHOD_OFFLINE,
self::METHOD_NONCE,        ];
    }
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getGatewayAllowableValues()
    {
        return [
            self::GATEWAY__2CHECKOUT,
self::GATEWAY_ADYEN,
self::GATEWAY_AMAZON,
self::GATEWAY_AUTHORIZENET,
self::GATEWAY_BANKDEPOSIT,
self::GATEWAY_BRAINTREE,
self::GATEWAY_CHEQUE,
self::GATEWAY_COD,
self::GATEWAY_CUSTOM,
self::GATEWAY_FIRSTDATAGGE4,
self::GATEWAY_GIFTCERTIFICATE,
self::GATEWAY_HPS,
self::GATEWAY_INSTORE,
self::GATEWAY_KLARNA,
self::GATEWAY_MIGS,
self::GATEWAY_MONEYORDER,
self::GATEWAY_NMI,
self::GATEWAY_PAYPALEXPRESS,
self::GATEWAY_PAYPALPAYMENTSPROUS,
self::GATEWAY_PAYPALPAYMENTSPROUK,
self::GATEWAY_PLUGNPAY,
self::GATEWAY_QBMSV2,
self::GATEWAY_SECURENET,
self::GATEWAY_SQUARE,
self::GATEWAY_STORECREDIT,
self::GATEWAY_STRIPE,
self::GATEWAY_TESTGATEWAY,
self::GATEWAY_USAEPAY,        ];
    }
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getStatusAllowableValues()
    {
        return [
            self::STATUS_OK,
self::STATUS_ERROR,        ];
    }

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['event'] = isset($data['event']) ? $data['event'] : null;
        $this->container['method'] = isset($data['method']) ? $data['method'] : null;
        $this->container['amount'] = isset($data['amount']) ? $data['amount'] : null;
        $this->container['currency'] = isset($data['currency']) ? $data['currency'] : null;
        $this->container['gateway'] = isset($data['gateway']) ? $data['gateway'] : null;
        $this->container['gateway_transaction_id'] = isset($data['gateway_transaction_id']) ? $data['gateway_transaction_id'] : null;
        $this->container['date_created'] = isset($data['date_created']) ? $data['date_created'] : null;
        $this->container['test'] = isset($data['test']) ? $data['test'] : null;
        $this->container['status'] = isset($data['status']) ? $data['status'] : null;
        $this->container['fraud_review'] = isset($data['fraud_review']) ? $data['fraud_review'] : null;
        $this->container['reference_transaction_id'] = isset($data['reference_transaction_id']) ? $data['reference_transaction_id'] : null;
        $this->container['offline'] = isset($data['offline']) ? $data['offline'] : null;
        $this->container['custom'] = isset($data['custom']) ? $data['custom'] : null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        if ($this->container['event'] === null) {
            $invalidProperties[] = "'event' can't be null";
        }
        $allowedValues = $this->getEventAllowableValues();
        if (!is_null($this->container['event']) && !in_array($this->container['event'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'event', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        if ($this->container['method'] === null) {
            $invalidProperties[] = "'method' can't be null";
        }
        $allowedValues = $this->getMethodAllowableValues();
        if (!is_null($this->container['method']) && !in_array($this->container['method'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'method', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        if ($this->container['amount'] === null) {
            $invalidProperties[] = "'amount' can't be null";
        }
        if ($this->container['currency'] === null) {
            $invalidProperties[] = "'currency' can't be null";
        }
        if ($this->container['gateway'] === null) {
            $invalidProperties[] = "'gateway' can't be null";
        }
        $allowedValues = $this->getGatewayAllowableValues();
        if (!is_null($this->container['gateway']) && !in_array($this->container['gateway'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'gateway', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getStatusAllowableValues();
        if (!is_null($this->container['status']) && !in_array($this->container['status'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'status', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets event
     *
     * @return string
     */
    public function getEvent()
    {
        return $this->container['event'];
    }

    /**
     * Sets event
     *
     * @param string $event Store event that created the transaction.
     *
     * @return $this
     */
    public function setEvent($event)
    {
        $allowedValues = $this->getEventAllowableValues();
        if (!in_array($event, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'event', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['event'] = $event;

        return $this;
    }

    /**
     * Gets method
     *
     * @return string
     */
    public function getMethod()
    {
        return $this->container['method'];
    }

    /**
     * Sets method
     *
     * @param string $method The payment method: `credit_card` - a credit-card transaction; `electronic_wallet` - an online wallet; `store_credit` - a transaction using store credit; `gift_certificate` - a transaction using a gift certificate; `custom` - manual payment methods; `token` - payment token; `nonce` - temporary payment token; `offsite` - online payment off the site (e.g., PayPal); `offline` - payment method that takes place offline.
     *
     * @return $this
     */
    public function setMethod($method)
    {
        $allowedValues = $this->getMethodAllowableValues();
        if (!in_array($method, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'method', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['method'] = $method;

        return $this;
    }

    /**
     * Gets amount
     *
     * @return float
     */
    public function getAmount()
    {
        return $this->container['amount'];
    }

    /**
     * Sets amount
     *
     * @param float $amount Amount of money in the transaction.
     *
     * @return $this
     */
    public function setAmount($amount)
    {
        $this->container['amount'] = $amount;

        return $this;
    }

    /**
     * Gets currency
     *
     * @return string
     */
    public function getCurrency()
    {
        return $this->container['currency'];
    }

    /**
     * Sets currency
     *
     * @param string $currency Currency used for the transaction.
     *
     * @return $this
     */
    public function setCurrency($currency)
    {
        $this->container['currency'] = $currency;

        return $this;
    }

    /**
     * Gets gateway
     *
     * @return string
     */
    public function getGateway()
    {
        return $this->container['gateway'];
    }

    /**
     * Sets gateway
     *
     * @param string $gateway The payment gateway, where applicable.
     *
     * @return $this
     */
    public function setGateway($gateway)
    {
        $allowedValues = $this->getGatewayAllowableValues();
        if (!in_array($gateway, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'gateway', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['gateway'] = $gateway;

        return $this;
    }

    /**
     * Gets gateway_transaction_id
     *
     * @return string
     */
    public function getGatewayTransactionId()
    {
        return $this->container['gateway_transaction_id'];
    }

    /**
     * Sets gateway_transaction_id
     *
     * @param string $gateway_transaction_id The transaction ID returned by the payment gateway for this transaction item.
     *
     * @return $this
     */
    public function setGatewayTransactionId($gateway_transaction_id)
    {
        $this->container['gateway_transaction_id'] = $gateway_transaction_id;

        return $this;
    }

    /**
     * Gets date_created
     *
     * @return \DateTime
     */
    public function getDateCreated()
    {
        return $this->container['date_created'];
    }

    /**
     * Sets date_created
     *
     * @param \DateTime $date_created The datetime of the transaction.
     *
     * @return $this
     */
    public function setDateCreated($date_created)
    {
        $this->container['date_created'] = $date_created;

        return $this;
    }

    /**
     * Gets test
     *
     * @return bool
     */
    public function getTest()
    {
        return $this->container['test'];
    }

    /**
     * Sets test
     *
     * @param bool $test True if the transaction performed was a test, or if the gateway is in test mode.
     *
     * @return $this
     */
    public function setTest($test)
    {
        $this->container['test'] = $test;

        return $this;
    }

    /**
     * Gets status
     *
     * @return string
     */
    public function getStatus()
    {
        return $this->container['status'];
    }

    /**
     * Sets status
     *
     * @param string $status Status of the transaction.
     *
     * @return $this
     */
    public function setStatus($status)
    {
        $allowedValues = $this->getStatusAllowableValues();
        if (!is_null($status) && !in_array($status, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'status', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['status'] = $status;

        return $this;
    }

    /**
     * Gets fraud_review
     *
     * @return bool
     */
    public function getFraudReview()
    {
        return $this->container['fraud_review'];
    }

    /**
     * Sets fraud_review
     *
     * @param bool $fraud_review Result of gateway fraud review, if any. Default is `false`.
     *
     * @return $this
     */
    public function setFraudReview($fraud_review)
    {
        $this->container['fraud_review'] = $fraud_review;

        return $this;
    }

    /**
     * Gets reference_transaction_id
     *
     * @return int
     */
    public function getReferenceTransactionId()
    {
        return $this->container['reference_transaction_id'];
    }

    /**
     * Sets reference_transaction_id
     *
     * @param int $reference_transaction_id Identifier for an existing transaction upon which this transaction acts.
     *
     * @return $this
     */
    public function setReferenceTransactionId($reference_transaction_id)
    {
        $this->container['reference_transaction_id'] = $reference_transaction_id;

        return $this;
    }

    /**
     * Gets offline
     *
     * @return \BigCommerce\OrdersV3\Model\Offline1
     */
    public function getOffline()
    {
        return $this->container['offline'];
    }

    /**
     * Sets offline
     *
     * @param \BigCommerce\OrdersV3\Model\Offline1 $offline offline
     *
     * @return $this
     */
    public function setOffline($offline)
    {
        $this->container['offline'] = $offline;

        return $this;
    }

    /**
     * Gets custom
     *
     * @return \BigCommerce\OrdersV3\Model\Custom1
     */
    public function getCustom()
    {
        return $this->container['custom'];
    }

    /**
     * Sets custom
     *
     * @param \BigCommerce\OrdersV3\Model\Custom1 $custom custom
     *
     * @return $this
     */
    public function setCustom($custom)
    {
        $this->container['custom'] = $custom;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed
     */
    public function offsetGet($offset)
    {
        return isset($this->container[$offset]) ? $this->container[$offset] : null;
    }

    /**
     * Sets value based on offset.
     *
     * @param integer $offset Offset
     * @param mixed   $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        if (defined('JSON_PRETTY_PRINT')) { // use JSON pretty print
            return json_encode(
                ObjectSerializer::sanitizeForSerialization($this),
                JSON_PRETTY_PRINT
            );
        }

        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}
